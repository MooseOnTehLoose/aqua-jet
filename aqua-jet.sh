#! /bin/bash

version="v0.0.9"
lb='\033[0;94m' # Blue - High Intensity
nc='\033[0m'    # No Color - resets to default
clear
echo -e "${lb}
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣀⣀⡂⣀⣀⠀⠀⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣄⣴⣲⠩⡩⠉⠉⢉⡘⣈⣳⢮⡽⣿⣧⣲⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠂⠁⣹⠆⠀⠸⢚⡳⡚⣭⣾⡍⢶⣾⣿⣿⣿⣿⣿⣿⣷⣦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢀⠴⣉⣀⡀⠀⣰⡯⡄⠐⣚⣢⣿⣷⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢀⡴⢡⣾⡿⠛⠏⢠⠟⠸⢐⣨⢴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⢠⠎⣼⣿⣿⢓⣆⣢⡦⣤⡔⠛⠉⠜⢛⣿⠟⠋⠁⠀⠀⠀⠀⠀⠈⠛⠟⣿⣿⣿⣿⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠛⠀⠿⢔⠟⢸⣻⣿⣿⣎⠛⢦⠀⣴⠛⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣿⣿⣿⣿⣿⣿⣿⣷⡄⠀⠀⠀⠀
⠀⠀⠀⠀⢠⠁⠀⠀⠀⠀⠀⢿⣿⣿⣿⣷⢨⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⣿⣿⣿⣿⣿⣿⣿⣇⠀⠀⠀⠀
⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⢀⠞⢁⣮⣯⣿⡟⠀⠀⠀⠀⠀⠀⠀⣀⣠⣄⡀⠀⠀⠀⠀⠀⠀⠀⠻⣿⣿⣿⣿⣿⣿⣯⡄⠀⠀⠀
⠀⠀⠀⠀⢸⠄⠀⠀⠀⠀⢎⣀⣸⣿⣷⡟⠁⠀⠀⠀⠀⠀⢀⣾⣿⣿⠿⢿⣦⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⠁⠀⠀⠀
⠀⠀⠀⠀⠈⡄⠀⠀⠀⠀⡉⠙⠉⠉⠁⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣇⠀⢀⣯⠀⠀⠀⠀⠀⠀⠐⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀
⠀⣞⠛⢒⡄⡱⡐⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠻⣿⢻⣿⣿⡿⠁⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀
⢸⡇⠀⡜⠂⠀⠑⢄⠀⠀⠔⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠋⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣟⣯⣽⣿⣿⣿⠂⠀⠀⠀
⠸⡇⠀⡧⠀⠐⠠⢀⠱⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣿⣿⣿⣿⣿⢿⣿⠃⠀⠀⠀⠀
⠀⣧⠀⢑⠀⠡⠐⢀⠠⠈⠱⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠄⠀⠀⠀⣠⠿⡫⡻⡻⡽⣻⠟⠁⠀⠀⠀⠀⠀
⠀⢻⡄⠀⡃⢀⠐⠠⠀⠂⠄⠨⣧⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀⣀⣠⣔⠟⠉⢼⡏⢿⣮⡷⠋⠀⠀⠀⠀⠀⠀⠀
⠀⠀⢻⡄⠈⢆⠀⠂⠁⡐⠠⠀⢪⣿⣿⣷⣶⣶⣤⣤⣤⣤⣤⣤⣤⣤⣤⣶⣿⣿⣿⣷⣶⣭⡾⠞⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⢳⣆⠉⡀⠀⠁⠀⡀⠄⣴⡿⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢿⣿⣿⣿⡿⣿⣏⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⣰⡿⣻⣦⣀⠀⠀⠄⠀⢰⠏⠀⢄⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣽⡎⢧⣽⣻⣷⣄⠙⢳⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⢿⣾⣿⡗⣝⡃⠁⠀⠀⡄⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⢿⣿⢾⣟⠽⢻⣿⣿⡄⢀⠈⠹⠦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⣻⠋⠀⠠⠂⠀⠄⠠⡄⢥⢨⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣳⠺⠧⢾⣿⡿⣯⡀⠀⠄⢀⠈⠂⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⢠⠍⣀⠀⠎⠀⠠⠀⠘⢲⢰⣚⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣟⣮⡽⣽⡿⠣⡾⢹⣗⡤⣄⠀⠠⠀⠈⢂⠀⠀⠀⠀⠀⠀
⠀⠀⠰⡄⠄⠀⠀⠀⠄⠂⠀⢿⣿⣫⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⣱⣽⡅⡯⣏⢑⠶⠍⣔⣀⣂⡭⠣⠀⠀⠀⠀⠀
⠀⠠⡇⠀⠁⠀⠀⠀⠂⠠⠁⠘⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣟⣿⣿⣿⣿⣿⡫⠙⡥⡲⣱⠧⠐⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⢹⠖⠠⠐⢄⠀⢈⠠⠐⠀⠈⠙⢿⣿⣿⣿⡻⢿⣿⣯⡷⣭⣟⣟⠊⠀⢄⡹⣮⠾⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⢧⡀⡄⠊⠘⣄⠀⠂⢁⠂⠀⠀⠈⠛⢿⢿⣷⡞⡟⣝⣁⣁⣠⣴⡼⠞⠋⠁⠀⢘⡧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠈⠳⣜⣄⠌⢚⢄⠁⠠⠀⠁⠀⠀⠀⠀⠀⠉⠉⠉⠉⠉⠩⠁⠀⠀⠀⠀⠀⠀⣴⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠈⢳⣆⣀⣈⣀⣄⣠⣔⡀⠀⠀⠀⠀⠀⠀⢀⠀⠄⠀⠀⠀⡀⠀⣀⣤⠾⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⡠⠔⠂⠽⠿⣿⣿⣗⠂⠀⢹⣦⠄⠀⠐⠀⠀⠀⠀⢀⣤⠶⠓⠐⢚⣍⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠐⠞⠠⢦⣶⣴⣾⣿⣿⣤⣴⣶⣤⠿⠛⠛⠛⠚⠛⠛⢛⣿⣷⣶⣿⣿⣶⣼⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠀⠉⠈⠀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠙⠛⠛⠛⠛⠛⠛⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡠⠀⠐⡁
Aqua-Jet ${version}${nc}"

remoteversion=$(curl -s https://api.github.com/repos/mooseontehloose/aqua-jet/tags |  jq -r '.[0].name')
if [[ $(echo -e "${version}\n${remoteversion}"|sort -V|head -1) != "${remoteversion}" ]]; then
  echo -e "Aqua-Jet is out of date! latest version is ${remoteversion}

  git clone https://github.com/MooseOnTehLoose/aqua-jet
  cd aqua-jet
  git tag
  git checkout <latest>
  "
  exit
fi


echo -e "\e]8;;https://github.com/MooseOnTehLoose/aqua-jet\e\\https://github.com/MooseOnTehLoose/aqua-jet\e]8;;\e\\"
printf "\n"

echo -e "Cloning https://github.com/spectrocloud/CanvOS into current directory"
git clone https://github.com/spectrocloud/CanvOS.git
cd CanvOS
canvos=$(git tag -l --sort=-v:refname | awk '!/-/' | head -n 1)
printf "\n"

# Choose Canvos Version
read -p "$(echo -e "Use latest CanvOS: ${lb}$canvos${nc} ? (y/n): " )" confirm

# Check the response
if [[ "$confirm" == "n" ]]; then
  #display all versions
  echo -e "Listing all Tags:\n"
  git tag -l --sort=-v:refname | awk '!/-/' | column
  printf "\n"
  read -p "Select CanvOS Version: " canvos 
fi

echo -e "Using tag: ${lb}$canvos${nc}\n"

git checkout $canvos
printf "\n"

read -p "Enter a custom tag for this build: " custom_tag
if [[ "$custom_tag" == "" ]]; then
  custom_tag="palette"
fi

clear
echo -e "${lb}Provider Image Registry Setup${nc}"
# ttl.sh no longer allows large images generated by CanvOS 
read -p "$(echo -e "Choose a remote registry location to push Provider Image - No HTTP(S):// ! \nex: harbor.test.com/edge\n\nRegistry: ")" image_registry

clear
echo -e "${lb}OS Setup${nc}"
read -p "$(echo -e "OS, choose from ubuntu, rhel, sles, leave blank for ${lb}ubuntu${nc}: " )" os
if [[ "$os" == "" ]]; then
  os="ubuntu"
fi

if [[ "$os" == "ubuntu" ]]; then
  default_os_version="22.04"
elif [[ "$os" == "sles" ]]; then
  default_os_version="5.4"
  disable_selinux="DISABLE_SELINUX=true"
  cis_hardening="CIS_HARDENING=false"
elif [[ "$os" == "rhel" ]]; then
  default_os_version="8.4"
fi

read -p "$(echo -e "OS Version, leave blank for $os ${lb}$default_os_version${nc}: ")" os_version
if [[ "$os_version" == "" ]]; then
  os_version=$default_os_version
fi

read -p "$(echo -e "Image Repo, leave blank for ${lb}$os${nc}: ")" image_repo
if [[ "$image_repo" == "" ]]; then
  image_repo=$os
fi

clear
echo -e "${lb}Kubernetes Setup${nc}"

k8s_type=("k3s" "kubeadm" "kubeadm-fips" "canonical" "nodeadm" "rke2")
read -p "$(echo -e "K8s Distribution, leave blank for ${lb}k3s${nc}\nChoices are: ${lb}${k8s_type[@]}${nc} \n")" k8s_distribution
if [[ "$k8s_distribution" == "" ]]; then
  k8s_distribution="k3s"
fi

if [[ ! " ${k8s_type[@]} " =~ " ${k8s_distribution} " ]]; then
  echo -e "Error: ${lb}${k8s_distribution}${nc} is not a valid option, exiting"
  exit
else
  echo -e "Choosing ${lb}${k8s_distribution}${nc}\n"
fi

echo -e "Possible versions for ${lb}$k8s_distribution${nc}:\n"

json=$(jq -c ".${k8s_distribution}[]"  ./k8s_version.json)
json_without_quotes=$(echo ${json//\"/""})

latest=$(jq -c ".${k8s_distribution} | last"  ./k8s_version.json )
latest_k8s=$(echo ${latest//\"/""})
k8s_array=($json_without_quotes)


printf "%s\n" "${k8s_array[@]}" | column -x -c 80
printf "\n"

echo -e "Latest is " ${lb}${latest_k8s}${nc}"\n"

read -p "K8s Version: " k8s_version
if [[ "$k8s_version" == "" ]]; then
  echo -e "Using latest version: ${lb}$latest_k8s${nc}"
  k8s_version="$latest_k8s"
fi
printf "\n"

clear
echo -e "${lb}ISO Setup${nc}"
read -p "$(echo -e "ISO Name, Leave blank to use: ${lb}$custom_tag-edge:$canvos-$os:$os_version-$k8s_distribution:$k8s_version.iso${nc} " )" iso_name
printf "\n"

if [[ "$iso_name" == "" ]]; then
  iso_name="$custom_tag-edge:$canvos-$os:$os_version-$k8s_distribution:$k8s_version"
  echo -e "Image File location: CanvOS/build/${lb}$iso_name.iso${nc}"
fi

base_image=""
if [[ "$os" == "sles" ]]; then
  read -p "$(echo -e "Default Base Image for SLEM/SLES: ${lb}docker.io/3pings/sles-m:v5.4-v22${nc} ")" slem_base_image
  
  if [[ "$slem_base_image" == "" ]]; then
  slem_base_image="docker.io/3pings/sles-m:v5.4-v22"
  fi

  base_image="BASE_IMAGE=$slem_base_image"
fi
printf "\n"

kernel="false"
read -p "Update Kernel? (y/n): " updatekernel
if [[ "$updatekernel" == "y" ]]; then
  kernel="true"
  echo -e "Updating kernel\n"
else
  echo -e "Not updating Kernel\n"
fi

clear
echo -e "${lb}Arg File Setup${nc}"

arg="CUSTOM_TAG=${custom_tag}
IMAGE_REGISTRY=${image_registry}
OS_DISTRIBUTION=${os}
OS_VERSION=${os_version}
IMAGE_REPO=${image_repo}
K8S_DISTRIBUTION=${k8s_distribution}
K8S_VERSION=${k8s_version}
ISO_NAME=${iso_name}
ARCH=amd64
${base_image}
${disable_selinux}
${cis_hardening}
UPDATE_KERNEL=${kernel}"

echo -e "arg file for build:\n\n$arg\n"
echo "$arg" > .arg

read -p "Modify .arg file before build? (y/n) " modifyarg
if [[ "$modifyarg" == "y" ]]; then
  vim ".arg"
fi

clear
echo -e "Choose Management Mode:

connected - You will provide an Edge Host Token and an API Endpoint. 
            Edge host will be managed by Palette

local     - You will provide a Palette API Key, the Project UI and the Profile(s) UID
            Edge host will be managed by Local UI

"

read -p "$(echo -e "Choose Management Mode: leave blank for ${lb}connected${nc} ")" managementMode
if [[ "$managementMode" == "" ]]; then
  managementMode="connected"
fi

if [[ "$managementMode" == "connected" ]]; then

  read -p "Edge Host Token: " edgehosttoken

  read -p "Palette Endpoint. Leave blank for api.spectrocloud.com: " paletteendpoint
  if [[ "$paletteendpoint" == "" ]]; then
    paletteendpoint="api.spectrocloud.com"
  fi

  stylusSite="site:
    paletteEndpoint: ${paletteendpoint}
    edgeHostToken: ${edgehosttoken}"

elif [[ "$managementMode" == "local" ]]; then
  stylusSite="managementMode: local"

else
  echo -e "Invalid Option, Exiting"
  exit 1
fi


clear
echo -e "${lb}User Data Setup${nc}"

encryptionEnabled=""
luksHotfix=""
read -p "Encrypt Partitions with LUKS? (y/n): " luks
if [[ "$luks" == "y" ]]; then
  encryptionEnabled="  encrypted_partitions:
  - COS_PERSISTENT"
  luksHotfix="
  before-reset:
    - name: \"reset persistent\"
      commands:
      - |
        #!/bin/bash
        udevadm trigger --subsystem-match=block
        udevadm trigger --type=all || udevadm trigger
        udevadm settle
        if [ -e /dev/disk/by-label/COS_PERSISTENT ]; then
          echo \"Persistent partition found\"
        else
          echo \"Persistent partition not found\"
          exit 0
        fi  
        # umount persistent partition
        umount /dev/disk/by-label/COS_PERSISTENT || true  
        # format persistent partition
        mkfs.ext4 /dev/disk/by-label/COS_PERSISTENT -L COS_PERSISTENT
reset:
  reset-persistent: false
"
fi

tui="false"
read -p "Include TUI? (y\n): " textui
if [[ "$textui" == "y" ]]; then
  tui="true"
fi


user="kairos"
password="kairos"

user_data="#cloud-config
stylus:
  ${stylusSite}
  includeTui: ${tui}
install:
  poweroff: true
${encryptionEnabled}  
stages:
  initramfs:
    - users:
        ${user}:
          groups:
            - sudo
          passwd: ${password}
      name: Create user and assign to sudo group
${luksHotfix}
"

echo -e "User data for build: \n" 
echo "$user_data" > user-data
cat user-data
printf "\n"

read -p "Modify User Data file before build? (y/n) " modifyuserdata
if [[ "$modifyuserdata" == "y" ]]; then
  vim "user-data"
fi

clear

echo -e "${lb}Earthly: Build ISO${nc}"

# Prompt for ISO Build
read -p "Ready to build ISO? (y/n) " buildiso
printf "\n"

# Check the response
if [[ "$buildiso" == "y" ]]; then
  ./earthly.sh +iso
  printf "\n"
else
  echo -e "Build ISO with ${lb}./earthly.sh +iso${nc}\n"
fi

echo -e "${lb}Earthly: Build Provider Image${nc}"

byos_template='pack:
  content:
    images:
      - image: "{{.spectro.pack.edge-native-byoi.options.system.uri}}"
  # Below config is default value, please uncomment if you want to modify default values
  #drain:
    #cordon: true
    #timeout: 60 # The length of time to wait before giving up, zero means infinite
    #gracePeriod: 60 # Period of time in seconds given to each pod to terminate gracefully. If negative, the default value specified in the pod will be used
    #ignoreDaemonSets: true
    #deleteLocalData: true # Continue even if there are pods using emptyDir (local data that will be deleted when the node is drained)
    #force: true # Continue even if there are pods that do not declare a controller
    #disableEviction: false # Force drain to use delete, even if eviction is supported. This will bypass checking PodDisruptionBudgets, use with caution
    #skipWaitForDeleteTimeout: 60 # If pod DeletionTimestamp older than N seconds, skip waiting for the pod. Seconds must be greater than 0 to skip.
options:
  system.uri: "{{ .spectro.pack.edge-native-byoi.options.system.registry }}/{{ .spectro.pack.edge-native-byoi.options.system.repo }}:{{ .spectro.pack.edge-native-byoi.options.system.k8sDistribution }}-{{ .spectro.system.kubernetes.version }}-{{ .spectro.pack.edge-native-byoi.options.system.peVersion }}-{{ .spectro.pack.edge-native-byoi.options.system.customTag }}"'
  
byos_data="
  system.registry: ${image_registry} 
  system.repo: ${image_repo}
  system.k8sDistribution: ${k8s_distribution}
  system.osName: ${os}
  system.peVersion: ${canvos}
  system.customTag: ${custom_tag}
  system.osVersion: ${os_version}"

echo "${byos_template} ${byos_data}" > "${custom_tag}-provider.yaml"
echo -e "BYOOS Layer yaml exported as: ${lb}${custom_tag}-provider.yaml${nc}\n"

# Prompt for Provider Image Build
read -p "Ready to build Provider Image? (y/n) " confirm
printf "\n"

# Check the response
if [[ "$confirm" == "y" ]]; then

  #Build the Provider image
  ./earthly.sh +build-provider-images
  echo -e "Pushing Provider image to Docker Registry:\ndocker push ${image_registry}/${os}:${k8s_distribution}-${k8s_version}-${canvos}-${custom_tag}"
  docker push ${image_registry}/${os}:${k8s_distribution}-${k8s_version}-${canvos}-${custom_tag}
else
  echo -e "Build Provider Image with:\n  ${lb}./earthly.sh +build-provider-images${nc}\n"
  echo -e "Push Provider Image with:\n  ${lb}docker push ${image_registry}/${os}:${k8s_distribution}-${k8s_version}-${canvos}-${custom_tag}${nc}\n"
fi

# Prompt for Content Build
read -p "Ready to build Content Bundle? (y/n) " confirm
printf "\n"

clear

# Check the response
if [[ "$confirm" == "y" ]]; then
  mkdir local-ui
  cd local-ui
  #figure out clean way to get the latest version, hardcoded for now
  wget -O "palette-edge" "https://software.spectrocloud.com/stylus/v4.8.8/cli/linux/palette-edge"
  chmod a+x ./palette-edge

  #API Key
  read -p "Palette API Key: " apikey
  
  #Split out the API Endpoint, Project UID and Profile UID
  read -p "Profile URL: " url

  if [[ "$url" =~ ^(https?://.[^/]+)/([^/]+)/([^/]+)/([^/]+)/([^/]+)/([^/]+)$ ]]; then
      apiendpoint="${BASH_REMATCH[1]}"
      projectuid="${BASH_REMATCH[3]}"
      profileuid="${BASH_REMATCH[6]}"
      echo -e "API Endpoint: ${apiendpoint}"
      echo -e "Project UID: ${projectuid}"
      echo -e "Profile UID: ${profileuid}"

  fi

  ./palette-edge build --api-key $apikey \
   --project-id $projectuid \
   --cluster-profile-ids $profileuid \
   --cluster-definition-profile-ids $profileuid \
   --palette-endpoint $apiendpoint \
   --cluster-definition-name ${custom_tag}-cluster-definition \
   --outfile "${custom_tag}-content-bundle" \
   --include-palette-content

fi